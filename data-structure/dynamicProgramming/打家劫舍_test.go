package dynamicProgramming

import "testing"

func TestRob(t *testing.T) {
	nums := []int{2, 7, 9, 3, 1}
	t.Log(rob(nums))
}

// rob 打家劫舍获取的最高金额
// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一个晚上被小偷闯入，系统会自动报警
// 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额

// 输入：[1,2,3,1]
// 输出：4
// 解释：偷窃1号房屋(金额 = 1)，然后偷窃3号房屋(金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4

// 输入：[2,7,9,3,1]
// 输出：12
// 解释：偷窃1号房屋(金额 = 2)，偷窃3号房屋(金额 = 9)，接着偷窃5号房屋(金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12

// 思路
// 数组中的值表示的是存放的金额，小偷可以选择偷和不偷，如果前一个偷了，那么下一个肯定是不能偷的，因为相邻的房屋在同一个晚上被小偷闯入，系统会自动报警。
// 如果上一个没偷，那么下一个可以选择偷也可以选择不偷，视情况而定。
func rob(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	var dp [][]int
	// 第1间房没偷的最高金额
	dp[0][0] = 0
	// 第1间房偷的最高金额
	dp[0][1] = nums[0]
	for i := 1; i < len(nums); i++ {
		// 不管第i-1间房偷没偷，第i间房都是可以不偷的，连续多间房不偷是不会报警的
		// 第i间房不偷的最高金额 = max(第i-1间房偷的最高金额,第i-1间房没偷的最高金额)
		dp[i][0] = max(dp[i-1][0], dp[i-1][1])

		// 第i间房偷了，那么第i-1间房必须没偷
		dp[i][1] = dp[i-1][0] + nums[i]
	}
	return max(dp[len(nums)-1][0], dp[len(nums)-1][1])
}

func robWithoutDp(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	// 定义两个变量，分别表示第i间房没偷和偷了的最高金额
	dp0, dp1 := 0, nums[0]
	for i := 1; i < len(nums); i++ {
		tmp := max(dp0, dp1)
		dp1 = dp0 + nums[i]
		dp0 = tmp
	}
	return max(dp0, dp1)
}
